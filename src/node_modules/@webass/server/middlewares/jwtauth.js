// extends request with `jwt`, `jwtData`, `jwtError` `jwtAuth`
/* options 
    {
      secret: string,
      expiration: '1hr|default',
      privateApi: false|default,
      base: 'api|deafult', //The api base/main folder inside /src/route
      privateApi: 'false|default', //if true, all api endpoints private and needs auth token
      api: {
        public: [], //list of endpoints that does not require token
      }
    }

*/
// helper methods
// await request.jwtAuth.isRequired() call inside endpoint to require jwt
// await request.jwtAuth.allowIf(async () => {}) on throw Error halts access, respond with json error
// sample usage, see /src/routes/api/tests/auth-ping.json.js


const url = require('url');
const querystring = require('querystring');
const jwt = require('jsonwebtoken');
const debug = require('debug')('Webass::jwtauth');

module.exports = jwtAuth;

async function setInReq(req, res, next) {
  this.req = req;
  this.res = res;
  this.next = next;
  req.jwtAuth = this;
  var uri = url.parse(req.url);
  var qs = querystring.parse(uri.query);
  var token;
  
  const bearerToken = req.headers.authorization;
  const xAuthToken = req.headers['x-auth-token'] || null;
  const getToken = qs['authToken'] || null;
  const cToken = req.cookies['authToken'] || null;
  //const pathname = url.parse(req.url).pathname;

  if(bearerToken) token = bearerToken.replace('Bearer ', '');
  if(xAuthToken) token = xAuthToken;
  if(getToken) token = getToken;
  if(cToken) token = cToken;
  debug('jwt', token);
  if(token) {
    req.jwt = token;
    try {
      req.jwtData = jwt.verify(token, this.opts.secret);
    } catch (e) {
      debug('error', e.message);
      req.jwtError = e.message;
      if(e.message.indexOf('expired')) {
        req.cookies = {};
      }
    } 
  }
  if(this.opts.privateApi) {
    var conf = this.opts.api || {};
    if(!conf.base) conf.base = 'api';
    if(!conf.public) conf.public = [];
    if(this.req.url.indexOf(`/${conf.base}/`) ===  0 && conf.public.indexOf(this.req.url) < 0) {
      try{
        await this.isRequired();
      } catch (e) {
        debug('isRequired:error', e);
      } 
    }
  }
  next();
    
}
function makeToken(payload) {
  var token = jwt.sign(payload, this.opts.secret, {expiresIn: this.opts.expiration});
  var info = jwt.decode(token);
  info.authToken = token;
  return info;
}

async function isRequired() {
  if(!this.req.jwt) {
    this.res.json({message: 'auth token not found.'}, 401);
  }
  if(!this.req.jwtData) {
    var message = 'auth data not found.';
    if(this.req.jwtError) {
      message = `auth token issue: ${this.req.jwtError}`;
    }
    this.res.json({message: message}, 401);
  }
  return;
}
/* throw Error inside cb to respond as error */
async function allowIf(cb) {
  try {
    await this.isRequired();
    await cb(this.req.jwtData);
  } catch (e) {
    this.res.json({message: e.message}, 401);
  }
}

function jwtAuth(opts) {
  if (!(this instanceof jwtAuth)) return new jwtAuth(opts);
  this.opts = Object.assign({expiration: '1hr', privateApi: false}, opts || {});
  this.makeToken = makeToken;
  this.isRequired = isRequired;
  this.allowIf = allowIf;
  debug('opts', this.opts);
  return setInReq.bind(this);
}